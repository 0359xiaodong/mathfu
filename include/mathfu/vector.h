/*
* Copyright 2014 Google Inc. All rights reserved.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
#ifndef MATHFU_VECTOR_H_
#define MATHFU_VECTOR_H_

#include "mathfu/utilities.h"

#include <math.h>

// Disable spurious warnings generated by MATHFU_VECTOR_OPERATION().
#if defined(_MSC_VER)
#pragma warning(push)
#pragma warning(disable: 4127)  // conditional expression is constant
#elif defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Warray-bounds"
#endif

#define MATHFU_VECTOR_OPERATION(OP) MATHFU_UNROLLED_LOOP(i, d, OP)

#define MATHFU_VECTOR_OPERATOR(OP) \
  { \
    Vector<T, d> result; \
    MATHFU_VECTOR_OPERATION(result[i] = OP); \
    return result; \
  }

#define MATHFU_VECTOR_SELF_OPERATOR(OP) \
  { \
    MATHFU_VECTOR_OPERATION(OP); \
    return *this; \
  }

namespace mathfu {

template<class T, int d> class Vector;

/// Packed N dimensional vector.
/// Some Vector classes are padded so that it's possible to use the data
/// structures with SIMD instructions.  This structure can be used in
/// conjunction with unpacked Vector classes to pack data
/// into flat arrays suitable for sending to a GPU (e.g vertex buffers).
///
/// For example, to pack (store) an unpacked to packed vector:
/// VectorPacked<float, 3> packed;
/// Vector<float, 3> vector(3, 2, 1);
/// vector.Pack(&packed);
///
/// or
///
/// Vector<float, 3> vector(3, 2, 1);
/// VectorPacked<float, 3> packed = vector;
///
/// To initialize a vector from a packed vector:
/// VectorPacked<float, 3> packed = { 3, 2, 1 };
/// Vector<float, 3> vector(packed);
///
template<class T, int d>
struct VectorPacked {
  VectorPacked() {}

  explicit VectorPacked(const Vector<T, d> &vector) {
    vector.Pack(this);
  }

  VectorPacked& operator=(const Vector<T, d> &vector) {
    vector.Pack(this);
    return *this;
  }

  T data[d];
};


/// @class Vector
/// Stores a vector of d elements with type T and provides a set of utility
/// operations on each vector.
template<class T, int d>
class Vector {
 public:
  /// Typedef the vector type as Scalar to allow for access of the type by other
  /// classes.
  typedef T Scalar;

  /// Create a vector of unitialized values.
  inline Vector() {}

  /// Create a vector from another vector copying each element.
  /// @param v Vector that the data will be copied from.
  inline Vector(const Vector<T, d>& v) {
    MATHFU_VECTOR_OPERATION(data_[i] = v.data_[i]);
  }

  /// Create a vector from another vector of a different type,
  // copying each element.
  // (e.g. to convert between float/double/int vectors).
  /// @param v Vector that the data will be copied from.
  template<typename U> explicit inline Vector(const Vector<U, d>& v) {
    MATHFU_VECTOR_OPERATION(data_[i] = static_cast<T>(v[i]));
  }

  /// Create a vector from a single float. Each elements is set to be equal to
  /// the value given.
  /// @param s Scalar value that the vector will be initialized to.
  explicit inline Vector(const T& s) {
    MATHFU_VECTOR_OPERATION(data_[i] = s);
  }

  /// Create a vector form the first d elements of an array.
  /// @param a Array of values that the vector will be iniitlized to.
  explicit inline Vector(const T* a) {
    MATHFU_VECTOR_OPERATION(data_[i] = a[i]);
  }

  /// Create a vector from two values. This method only works when the vector
  /// is of size two.
  /// @param s1 Scalar value for the first element of the vector.
  /// @param s2 Scalar value for the second element of the vector.
  inline Vector(const T& s1, const T& s2) {
    MATHFU_STATIC_ASSERT(d == 2);
    data_[0] = s1;
    data_[1] = s2;
  }

  /// Create a vector from three values. This method only works when the vector
  /// is of size three.
  /// @param s1 Scalar value for the first element of the vector.
  /// @param s2 Scalar value for the second element of the vector.
  /// @param s3 Scalar value for the third element of the vector.
  inline Vector(const T& s1, const T& s2, const T& s3) {
    MATHFU_STATIC_ASSERT(d == 3);
    data_[0] = s1;
    data_[1] = s2;
    data_[2] = s3;
  }

  /// Create a vector from four values. This method only works when the vector
  /// is of size four.
  /// @param s1 Scalar value for the first element of the vector.
  /// @param s2 Scalar value for the second element of the vector.
  /// @param s3 Scalar value for the third element of the vector.
  /// @param s4 Scalar value for the forth element of the vector.
  inline Vector(const T& s1, const T& s2, const T& s3, const T& s4) {
    MATHFU_STATIC_ASSERT(d == 4);
    data_[0] = s1;
    data_[1] = s2;
    data_[2] = s3;
    data_[3] = s4;
  }

  /// Create a vector from a Vector<T, 3> initializing the last element to
  /// the specified value.  This method only works for 4 element vectors.
  /// @param vector3 Vector used to initialize the first 3 elements.
  /// @param value Value used to set the last element of the vector.
  inline Vector(const Vector<T, 3>& vector3, const T& value) {
    MATHFU_STATIC_ASSERT(d == 4);
    data_[0] = vector3[0];
    data_[1] = vector3[1];
    data_[2] = vector3[2];
    data_[3] = value;
  }

  /// Create a vector from packed vector.
  /// @param vector Packed vector used to initialize an unpacked.
  explicit inline Vector(const VectorPacked<T, d>& vector) {
    MATHFU_VECTOR_OPERATION(data_[i] = vector.data[i]);
  }

  inline T& operator()(const int i) {
    return data_[i];
  }

  inline const T& operator()(const int i) const {
    return data_[i];
  }

  /// Access an element of the vector.
  /// @param i The index to access.
  /// @return A reference to the accessed data that can be modified by the
  /// caller.
  inline T& operator[](const int i) {
    return data_[i];
  }

  /// Access an element of the vector.
  /// @param i The index to access.
  /// @return A const reference to the accessed data that cannot be modified
  /// by the caller.
  inline const T& operator[](const int i) const {
    return data_[i];
  }

  /// Convenient named element accessors.
  inline T& x() { MATHFU_STATIC_ASSERT(d > 0); return data_[0]; }
  inline T& y() { MATHFU_STATIC_ASSERT(d > 1); return data_[1]; }
  inline T& z() { MATHFU_STATIC_ASSERT(d > 2); return data_[2]; }
  inline T& w() { MATHFU_STATIC_ASSERT(d > 3); return data_[3]; }

  inline const T& x() const { MATHFU_STATIC_ASSERT(d > 0); return data_[0]; }
  inline const T& y() const { MATHFU_STATIC_ASSERT(d > 1); return data_[1]; }
  inline const T& z() const { MATHFU_STATIC_ASSERT(d > 2); return data_[2]; }
  inline const T& w() const { MATHFU_STATIC_ASSERT(d > 3); return data_[3]; }

  /// GLSL style multi-component accessors.
  inline Vector<T, 3> xyz() {
    MATHFU_STATIC_ASSERT(d > 3);
    return Vector<T, 3>(x(), y(), z());
  }

  inline const Vector<T, 3> xyz() const {
    MATHFU_STATIC_ASSERT(d > 3);
    return Vector<T, 3>(x(), y(), z());
  }

  inline Vector<T, 3> xy() {
    MATHFU_STATIC_ASSERT(d > 2);
    return Vector<T, 3>(x(), y());
  }

  inline const Vector<T, 3> xy() const {
    MATHFU_STATIC_ASSERT(d > 2);
    return Vector<T, 3>(x(), y());
  }

  /// Pack a vector to a packed "d" element vector structure.
  /// @param vector Packed "d" element vector to write to.
  inline void Pack(VectorPacked<T, d> * const vector) const {
    MATHFU_VECTOR_OPERATION(vector->data[i] = data_[i]);
  }

  /// Vector negation.
  /// @return A new vector that stores the negation result.
  inline Vector<T, d> operator-() const {
    MATHFU_VECTOR_OPERATOR(-data_[i]);
  }

  /// Vector mulitplication. Note that in line with GLSL this does componentwise
  /// multiplication.
  /// @param v A vector to mulitply this vector with.
  /// @return A new vector that stores the result.
  inline Vector<T, d> operator*(const Vector<T, d>& v) const {
    return HadamardProduct(*this, v);
  }

  /// Vector division. Note that in line with GLSL this does componentwise
  /// division.
  /// @param v A vector to divide this vector by.
  /// @return A new vector that stores the result.
  inline Vector<T, d> operator/(const Vector<T, d>& v) const {
    MATHFU_VECTOR_OPERATOR(data_[i] / v[i]);
  }

  /// Vector addition.
  /// @param v A vector to add this vector with.
  /// @return A new vector that stores the result.
  inline Vector<T, d> operator+(const Vector<T, d>& v) const {
    MATHFU_VECTOR_OPERATOR(data_[i] + v[i]);
  }

  /// Vector subtraction.
  /// @param v A vector to subtract from this vector.
  /// @return A new vector that stores the result.
  inline Vector<T, d> operator-(const Vector<T, d>& v) const {
    MATHFU_VECTOR_OPERATOR(data_[i] - v[i]);
  }

  /// Vector/Scalar multiplication.
  /// @param s A scalar to multiply this vector with.
  /// @return A new vector that stores the result.
  inline Vector<T, d> operator*(const T& s) const {
    MATHFU_VECTOR_OPERATOR(data_[i] * s);
  }

  /// Vector/Scalar division. Note that this is defined as multiplication by
  /// the inverse of the scalar.
  /// @param s A scalar to divide this vector with.
  /// @return A new vector that stores the result.
  inline Vector<T, d> operator/(const T& s) const {
    MATHFU_VECTOR_OPERATOR(data_[i] / s);
  }

  /// Vector/Scalar addition. Note that this is defined as addition between
  /// the origional vector and the scalar multiplied by a vector of ones.
  /// @param s A scalar to add to this vector.
  /// @return A new vector that stores the result.
  inline Vector<T, d> operator+(const T& s) const {
    MATHFU_VECTOR_OPERATOR(data_[i] + s);
  }

  /// Vector/Scalar subtraction. Note that this is defined as subtraction
  /// between the origional vector and the scalar multiplied by a vector of
  /// ones.
  /// @param s A scalar to subtract from this vector.
  /// @return A new vector that stores the result.
  inline Vector<T, d> operator-(const T& s) const {
    MATHFU_VECTOR_OPERATOR(data_[i] - s);
  }

  /// In place vector multiplication. Note that in line with GLSL this does
  /// componentwise multiplication.
  /// @param v A vector to multiply this vector with.
  /// @return A reference to this class.
  inline Vector<T, d>& operator*=(const Vector<T, d>& v) {
    MATHFU_VECTOR_SELF_OPERATOR(data_[i] *= v[i]);
  }

  /// In place vector division. Note that in line with GLSL this does
  /// componentwise division.
  /// @param v A vector to divide this vector by.
  /// @return A reference to this class.
  inline Vector<T, d>& operator/=(const Vector<T, d>& v) {
    MATHFU_VECTOR_SELF_OPERATOR(data_[i] /= v[i]);
  }

  /// In place vector addition.
  /// @param v A vector to add this vector with.
  /// @return A reference to this class.
  inline Vector<T, d>& operator+=(const Vector<T, d>& v) {
    MATHFU_VECTOR_SELF_OPERATOR(data_[i] += v[i]);
  }

  /// In place vector subtraction.
  /// @param v A vector to subtract this vector by.
  /// @return A reference to this class.
  inline Vector<T, d>& operator-=(const Vector<T, d>& v) {
    MATHFU_VECTOR_SELF_OPERATOR(data_[i] -= v[i]);
  }

  /// In place vector/scalar multiplication.
  /// @param s A scalar to mulitply this vector with.
  /// @return A reference to this class.
  inline Vector<T, d>& operator*=(const T& s) {
    MATHFU_VECTOR_SELF_OPERATOR(data_[i] *= s);
  }

  /// In place vector/scalar division. Note that this is defined as
  /// multiplication by the inverse of the scalar.
  /// @param s A scalar to divide this vector by.
  /// @return A reference to this class.
  inline Vector<T, d>& operator/=(const T& s) {
    MATHFU_VECTOR_SELF_OPERATOR(data_[i] /= s);
  }

  /// In place vector/scalar addition. Note that this is defined as addition
  /// between the origional vector and the scalar multiplied by a vector of
  /// ones.
  /// @param s A scalar to add this vector to.
  /// @return A reference to this class.
  inline Vector<T, d>& operator+=(const T& s) {
    MATHFU_VECTOR_SELF_OPERATOR(data_[i] += s);
  }

  /// In place vector/scalar subtraction. Note that this is defined as
  /// subtraction between the origional vector and the scalar multiplied by a
  /// vector of ones.
  /// @param s A scalar to subtract from this vector.
  /// @return A reference to this class.
  inline Vector<T, d>& operator-=(const T& s) {
    MATHFU_VECTOR_SELF_OPERATOR(data_[i] -= s);
  }

  /// Find length squared.
  /// @return The length of this vector squared.
  inline T LengthSquared() const {
    return DotProduct(*this,*this);
  }

  /// Find length.
  /// @return The length of this vector.
  inline T Length() const {
    return sqrt(LengthSquared());
  }

  /// Normalize this vector.
  /// @return The length of this vector.
  inline T Normalize() {
    const T length = Length();
    *this = *this*(1 / length);
    return length;
  }

  /// Find a Normalized version of this vector.
  /// @return A copy of this vector normalized.
  inline Vector<T, d> Normalized() const {
    return *this*(1 / Length());
  }

  /// Caclculate the dot product of two vectors.
  /// @param v1 First vector.
  /// @param v2 Second vector.
  /// @return The dot product of v1 and v2.
  static inline T DotProduct(
    const Vector<T, d>& v1, const Vector<T, d>& v2) {
    if(d == 2) return v1[0] * v2[0] + v1[1] * v2[1];
    if(d == 3) return v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2];
    if(d == 4)
      return v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2] + v1[3] * v2[3];
    if(d > 4) {
      T result = 0; MATHFU_VECTOR_OPERATION(result += v1[i] * v2[i]);
      return result;
    }
  }

  /// Calculate the hadamard or componentwise product of two vectors.
  /// @param v1 First vector.
  /// @param v2 Second vector.
  /// @return The hadamard product of v1 and v2.
  static inline Vector<T, d> HadamardProduct(
      const Vector<T, d>& v1, const Vector<T, d>& v2) {
    MATHFU_VECTOR_OPERATOR(v1[i] * v2[i]);
  }

  /// Calculate the cross product of two vectors. Note that this function is
  /// only defined for Vectors with length 3.
  /// @param v1 First vector.
  /// @param v2 Second vector.
  /// @return The cross product of v1 and v2.
  static inline Vector<T, 3> CrossProduct(
    const Vector<T, 3>& v1,const Vector<T, 3>& v2) {
    return Vector<T, 3>(
      v1[1] * v2[2] - v1[2] * v2[1], v1[2] * v2[0] - v1[0] * v2[2],
      v1[0] * v2[1] - v1[1] * v2[0]);
  }

  /// Linearly interpolate two vectors.
  /// @param v1 First vector.
  /// @param v2 Second vector.
  /// @param percent Percentage from v1 to v2. In range 0~1.
  /// @return The hadamard product of v1 and v2.
  static inline Vector<T, d> Lerp(
      const Vector<T, d>& v1, const Vector<T, d>& v2, const T percent) {
    const T one_minus_percent = static_cast<T>(1.0) - percent;
    MATHFU_VECTOR_OPERATOR(one_minus_percent * v1[i] + percent * v2[i]);
  }

  /// Generates a random vector, where the range for each component is
  /// bounded by min and max.
  static inline Vector<T, d> RandomInRange(
      const Vector<T, d>& min, const Vector<T, d>& max) {
    Vector<T, d> result;
    MATHFU_VECTOR_OPERATION(result[i] =
        mathfu::RandomInRange<T>(min[i], max[i]));
    return result;
  }

 private:
  T data_[d];
};

template<class T, int d>
inline Vector<T, d> operator*(const T& s, const Vector<T, d>& v) {
  return v * s;
}

template<class T, int d>
inline Vector<T, d> operator/(const T& s, const Vector<T, d>& v) {
  return v / s;
}

template<class T, int d>
inline Vector<T, d> operator+(const T& s, const Vector<T, d>& v) {
  return v + s;
}

template<class T, int d>
inline Vector<T, d> operator-(const T& s, const Vector<T, d>& v) {
  return v - s;
}

}  // namespace mathfu

#if defined(_MSC_VER)
#pragma warning(pop)
#elif defined(__clang__)
#pragma clang diagnostic pop
#endif

#endif  // MATHFU_VECTOR_H_
